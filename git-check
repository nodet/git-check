#!/bin/sh -e
#
# Sanity checks to confirm that I didn't do anything silly
# before pushing to origin.
#
# This code was written by Xavier Nodet <xavier.nodet@gmail.com>
# SPDX-License-Identifier: Unlicense
#

VERSION="0.9.3"
DEBUG=0

# Default command to use to list commits
LOG_DEFAULT="log --oneline"
# Set the command from env var, or default if not set
LOG="${GIT_CHECK_LOG_CMD:="$LOG_DEFAULT"}"

show_help() {
    echo "Usage: git check [-d] [-l command] [ref]"
    echo "       git check -h"
    echo "       git check -v"
    echo
    echo "Show the commits between the specified reference (or HEAD) and the"
    echo "earliest commit that appears on 'origin'."
    echo
    echo "  -h     Show this help message."
    echo "  -v     Show version number."
    echo "  -d     Print debugging messages."
    echo "  -l     Command to use to log the commits."
    echo "         Defaults to the value of \$GIT_CHECK_LOG_CMD, and"
    echo "         '$LOG_DEFAULT' if that variable is not set."
    echo "  ref    Commit to start from, defaults to HEAD."
    echo
    echo "Example: git check aa89ff6"
    echo ""
    echo "This script was written by Xavier Nodet <xavier.nodet@gmail.com>"
    echo "and is Unlicensed <http://unlicense.org/>."
}

debug() {
    if test "$DEBUG" == "1"; then
        echo $*
    fi
}

show_version() {
    echo "git-check $VERSION"
}

while getopts ":hvdl:" opt; do
  case ${opt} in
    d)
        DEBUG=1
        ;;
    h)
        show_help
        exit 0
        ;;
    v)
        show_version
        exit 0
        ;;
    l)
        LOG=$OPTARG
        ;;
    \?)
        echo "Invalid option: -${OPTARG}."
        exit 1
        ;;
    :)
        echo "Invalid option: -$OPTARG requires an argument"
        show_help
        exit 1
  esac
done
shift $((OPTIND -1))

if test $# -gt 1; then
    echo "Too many arguments: '$*'"
    show_help
    exit 1
fi

ref=$1
if [[ "$ref" == "" ]]; then
    ref="HEAD"
fi

# Get the name of the current branch
ref_branch=$(git name-rev --name-only $ref)
if [ "$ref_branch" == "undefined" ]; then
    # If we're not on a branch, 'undefined' would trigger an error later
    ref_branch=$ref
fi

# Initialize a variable to store the latest common commit
incumbent=""
# and one to store the branch it's on
incumbent_branch=""

# Iterate over all the branches from 'origin'
all_branches=$(git for-each-ref --format='%(refname:short)' refs/remotes | grep "^origin/")
for branch in $all_branches; do
    debug "Checking $branch"
    # Find the latest common commit between the current branch and the ref iteration branch
    common_commit=$(git merge-base "$ref_branch" "$branch")
    debug "Merge-base on $branch is $common_commit"
    if [ "$common_commit" == "$incumbent" ]; then
        # The commit that would be the fork appears on several branches
        # We compare the number of commits that each branch has and the other
        # doesn't, and we keep the branch that has fewer of these.  In our
        # workflow, this is a release branch, as opposed to main.
        debug "This commit is our incumbent solution"
        nb_on_base_not_branch=$(git log --oneline $incumbent_branch --not $branch | wc -l)

        debug "There are $nb_on_base_not_branch commits to go from $incumbent_branch to $branch"

        nb_on_branch_not_base=$(git log --oneline $branch --not $incumbent_branch | wc -l)

        debug "There are $nb_on_branch_not_base commits to go from $branch to $incumbent_branch"

        if test $nb_on_branch_not_base -lt $nb_on_base_not_branch; then
            debug "We store the new base $common_commit on $branch"
            incumbent=$common_commit
            incumbent_branch=$branch

        else
            debug "We keep the incumbent"
        fi
        # No further consideration required
        continue
    fi
    # If incumbent is empty, initialize it
    # and be done for that branch
    if [ -z "$incumbent" ]; then
        incumbent=$common_commit
        incumbent_branch=$branch

        continue
    fi
    # Compare the ref common commit with the incumbent and
    # update if necessary. 'git merge-base --is-ancestor' exits with 0 if
    # the first commit (the one we knew already) is an ancestor of the second
    # commit (on the branch we're testing). When that is the case, we want to
    # store the latter.
    if git merge-base --is-ancestor $incumbent $common_commit; then
        debug "$incumbent (on $incumbent_branch) is an ancestor of $common_commit (on $branch), storing the latter" 1>&2

        incumbent=$common_commit
        incumbent_branch=$branch

        continue
    fi
done

# We now have found where the branch was created from

# Get the short version of the commit id
incumbent=`git rev-parse --short $incumbent`

# Display the results
ref_id=$(git rev-parse --short $ref)
if test "$ref_id" == "$incumbent"; then
    branch_tip=$(git rev-parse --short "$incumbent_branch")

    if [ "$ref_id" == "$branch_tip" ]; then
        echo "$ref is the tip of $incumbent_branch"

    else
        echo "$ref belongs to $incumbent_branch"

    fi
    git $LOG -1 $common_id
else
    echo "$ref is based on $incumbent_branch ($incumbent):"

    git $LOG $incumbent..$ref
    git $LOG -1 $incumbent
    echo "Modified files:"
    git diff --name-status $incumbent..$ref
fi
