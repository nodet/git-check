#!/bin/sh -e
#
# Sanity checks to confirm that I didn't do anything silly
# before pushing to origin.
#
# This code was written by Xavier Nodet <xavier.nodet@gmail.com>
# SPDX-License-Identifier: Unlicense
#

VERSION="0.9.3"
DEBUG=0

# Default command to use to list commits
LOG_DEFAULT="log --oneline"
# Set the command from env var, or default if not set
LOG="${GIT_CHECK_LOG_CMD:="$LOG_DEFAULT"}"

show_help() {
    echo "Usage: git check [-l command] [ref]"
    echo "       git check -h"
    echo "       git check -v"
    echo
    echo "  -h     Show this help message."
    echo "  -v     Show version number."
    echo "  -d     Print debugging messages."
    echo "  -l     Command to use to log the commits."
    echo "         Defaults to the value of \$GIT_CHECK_LOG_CMD, and"
    echo "         '$LOG_DEFAULT' if that variable is not set."
    echo "  ref    Commit to check, defaults to HEAD."
    echo
    echo "Example: git check aa89ff6"
    echo ""
    echo "This script was written by Xavier Nodet <xavier.nodet@gmail.com>"
    echo "and is Unlicensed <http://unlicense.org/>."
}

debug() {
    if test "$DEBUG" == "1"; then
        echo $*
    fi
}

show_version() {
    echo "git-check $VERSION"
}

while getopts ":hvdl:" opt; do
  case ${opt} in
    d)
        DEBUG=1
        ;;
    h)
        show_help
        exit 0
        ;;
    v)
        show_version
        exit 0
        ;;
    l)
        LOG=$OPTARG
        ;;
    \?)
        echo "Invalid option: -${OPTARG}."
        exit 1
        ;;
    :)
        echo "Invalid option: -$OPTARG requires an argument"
        show_help
        exit 1
  esac
done
shift $((OPTIND -1))

if test $# -gt 1; then
    echo "Too many arguments: '$*'"
    show_help
    exit 1
fi

current=$1
if [[ "$current" == "" ]]; then
    current="HEAD"
fi

# Get the name of the current branch
current_branch=$(git name-rev --name-only $current)
if [ "$current_branch" == "undefined" ]; then
    # If we're not on a branch, 'undefined' would trigger an error later
    current_branch=$current
fi

# Initialize a variable to store the latest common commit
common_ancestor=""
# one to store the branch it's on
base_branch=""
# and one to indicate whether it's the tip of that branch
is_a_tip=false

# Iterate over all the branches from 'origin'
all_branches=$(git for-each-ref --format='%(refname:short)' refs/remotes | grep "^origin/")
for branch in $all_branches; do
    debug "Checking $branch"
    # Find the latest common commit between the current branch and the current iteration branch
    common_commit=$(git merge-base "$current_branch" "$branch")
    debug "Merge-base on $branch is $common_commit"
    if [ "$common_commit" == "$common_ancestor" ]; then
        # The commit that would be the fork appears on several branches
        # We compare the number of commits that each branch has and the other
        # doesn't, and we keep the branch that has fewer of these.  In our
        # workflow, this is a release branch, as opposed to main.
        debug "This commit is our incumbent solution"
        nb_on_base_not_branch=$(git log --oneline $base_branch --not $branch | wc -l)
        debug "There are $nb_on_base_not_branch commits to go from $base_branch to $branch"
        nb_on_branch_not_base=$(git log --oneline $branch --not $base_branch | wc -l)
        debug "There are $nb_on_branch_not_base commits to go from $branch to $base_branch"
        if test $nb_on_branch_not_base -lt $nb_on_base_not_branch; then
            debug "We store the new base $common_commit on $branch"
            common_ancestor=$common_commit
            base_branch=$branch
            is_a_tip=$this_one_is_a_tip
        else
            debug "We keep the incumbent"
        fi
        # No further consideration required
        continue
    fi
    # Is this commit the tip of the branch we test?
    branch_tip=$(git rev-parse "$branch")
    if [ "$common_commit" == "$branch_tip" ]; then
        this_one_is_a_tip=true
    else
        this_one_is_a_tip=false
    fi
    # If common_ancestor is empty, initialize it
    # and be done for that branch
    if [ -z "$common_ancestor" ]; then
        common_ancestor=$common_commit
        base_branch=$branch
        is_a_tip=$this_one_is_a_tip
        continue
    fi
    # Compare the current common commit with the common_ancestor and
    # update if necessary. 'git merge-base --is-ancestor' exits with 0 if
    # the first commit (the one we knew already) is an ancestor of the second
    # commit (on the branch we're testing). When that is the case, we want to
    # store the latter.
    if git merge-base --is-ancestor $common_ancestor $common_commit; then
        debug "$common_ancestor (on $base_branch) is an ancestor of $common_commit (on $branch), storing the latter" 1>&2
        common_ancestor=$common_commit
        base_branch=$branch
        is_a_tip=$this_one_is_a_tip
        continue
    fi
    if test "$is_a_tip" == "true" && test "$this_one_is_a_tip" == "false"; then
        # This one is not the tip of a branch. If we have a tip, we
        # discard that one.
        debug "Incumbent is the tip of a branch, when $common_commit is not. Leaving as is."
        continue
    fi
done

# We now have found where the branch was created from

# Get the short version of the commit id
common_ancestor=`git rev-parse --short $common_ancestor`

# Display the results
current_id=$(git rev-parse --short $current)
if test "$current_id" == "$common_ancestor"; then
    if test "$is_a_tip" == "true"; then
        echo "$current is the tip of $base_branch"
    else
        echo "$current belongs to $base_branch"
    fi
else
    echo "$current is based on $base_branch ($common_ancestor):"
    git $LOG $common_ancestor..$current
    git $LOG -1 $common_ancestor
    echo "Modified files:"
    git diff --name-status $common_ancestor..$current
fi
